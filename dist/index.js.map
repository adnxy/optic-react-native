{"version":3,"sources":["../src/store/metricsStore.ts","../src/metrics/tti.ts","../src/metrics/startup.ts","../src/metrics/reRenders.ts","../src/index.ts","../src/core/initOptic.ts","../src/overlay/Overlay.tsx","../src/metrics/screen.ts"],"sourcesContent":["import { create } from 'zustand';\n\ninterface ScreenMetrics {\n  tti: number | null;\n  reRenderCounts: Record<string, number>;\n}\n\ninterface MetricsState {\n  currentScreen: string | null;\n  screens: Record<string, ScreenMetrics>;\n  startupTime: number | null;\n  setCurrentScreen: (screenName: string) => void;\n  setTTI: (tti: number | null) => void;\n  setStartupTime: (startupTime: number) => void;\n  incrementReRender: (componentName: string) => void;\n}\n\nconst createScreenMetrics = (): ScreenMetrics => ({\n  tti: null,\n  reRenderCounts: {},\n});\n\nexport const useMetricsStore = create<MetricsState>((set, get) => ({\n  currentScreen: null,\n  screens: {},\n  startupTime: null,\n  setCurrentScreen: (screenName) => {\n    const state = get();\n    // Only update if the screen actually changed\n    if (state.currentScreen !== screenName) {\n      console.log(`[useoptic] Setting current screen to: ${screenName}`);\n      set((state) => {\n        // Initialize metrics for new screen if it doesn't exist\n        if (!state.screens[screenName]) {\n          return {\n            currentScreen: screenName,\n            screens: {\n              ...state.screens,\n              [screenName]: createScreenMetrics(),\n            },\n          };\n        }\n        return { currentScreen: screenName };\n      });\n    }\n  },\n  setTTI: (tti) => {\n    const state = get();\n    if (!state.currentScreen) {\n      console.log('[useoptic] Cannot set TTI: no current screen');\n      return;\n    }\n    \n    // Only update if TTI actually changed\n    const currentTTI = state.screens[state.currentScreen]?.tti;\n    if (currentTTI !== tti) {\n      console.log(`[useoptic] Setting TTI for ${state.currentScreen}: ${tti}ms`);\n      set((state) => ({\n        screens: {\n          ...state.screens,\n          [state.currentScreen!]: {\n            ...state.screens[state.currentScreen!],\n            tti,\n          },\n        },\n      }));\n    }\n  },\n  setStartupTime: (startupTime) => {\n    const state = get();\n    // Only update if startup time actually changed\n    if (state.startupTime !== startupTime) {\n      console.log(`[useoptic] Setting startup time: ${startupTime}ms`);\n      set({ startupTime });\n    }\n  },\n  incrementReRender: (componentName) => {\n    const state = get();\n    if (!state.currentScreen) return;\n    \n    const currentScreen = state.screens[state.currentScreen];\n    const currentCount = currentScreen.reRenderCounts[componentName] || 0;\n    \n    set((state) => ({\n      screens: {\n        ...state.screens,\n        [state.currentScreen!]: {\n          ...currentScreen,\n          reRenderCounts: {\n            ...currentScreen.reRenderCounts,\n            [componentName]: currentCount + 1,\n          },\n        },\n      },\n    }));\n  },\n}));","import { useMetricsStore } from '../store/metricsStore';\n\nexport function trackTTI() {\n  if ((global as any).__OPTIC_TTI_CAPTURED__) return;\n  const start = Date.now();\n  requestAnimationFrame(() => {\n    const tti = Date.now() - start;\n    (global as any).__OPTIC_TTI_CAPTURED__ = true;\n    useMetricsStore.getState().setTTI(tti);\n    console.log(`[useoptic] TTI measured: ${tti}ms`);\n  });\n}","export {};\n\nimport { useMetricsStore } from '../store/metricsStore';\n\n// Global app start time (should be set as early as possible in the app entrypoint)\ndeclare global {\n  var __OPTIC_APP_START_TIME__: number | undefined;\n  var __OPTIC_STARTUP_CAPTURED__: boolean;\n}\n\nif (global.__OPTIC_APP_START_TIME__ === undefined) {\n  global.__OPTIC_APP_START_TIME__ = Date.now();\n}\n\nif (global.__OPTIC_STARTUP_CAPTURED__ === undefined) {\n  global.__OPTIC_STARTUP_CAPTURED__ = false;\n}\n\n/**\n * Measures time since global app start and logs it to the console.\n * Only measures once and stores the result.\n */\nexport function trackStartupTime() {\n  // Only measure startup time once\n  if (global.__OPTIC_STARTUP_CAPTURED__) {\n    return;\n  }\n\n  const start = global.__OPTIC_APP_START_TIME__ || Date.now();\n  \n  // Use requestAnimationFrame to ensure we measure after initial render\n  requestAnimationFrame(() => {\n    if (!global.__OPTIC_STARTUP_CAPTURED__) {\n      const duration = Date.now() - start;\n      \n      // Mark as captured before setting the time to prevent race conditions\n      global.__OPTIC_STARTUP_CAPTURED__ = true;\n      \n      useMetricsStore.getState().setStartupTime(duration);\n      console.log(`[useoptic] Startup time: ${duration}ms`);\n    }\n  });\n}\n","import * as React from 'react';\nimport { useMetricsStore } from '../store/metricsStore';\n\nconst { useEffect, useRef } = React;\n\n/**\n * Hook to monitor and log prop changes for a component.\n * @param componentName Name of the component\n * @param props Component props\n */\nexport function useRenderMonitor<T extends Record<string, any>>(\n  componentName: string,\n  props: T\n) {\n  if (!React) {\n    console.error('[useoptic] React is not available. Make sure React is properly imported.');\n    return;\n  }\n\n  const prevProps = useRef<T | null>(null);\n  const incrementReRender = useMetricsStore((state) => state.incrementReRender);\n  const currentScreen = useMetricsStore((state) => state.currentScreen);\n\n  useEffect(() => {\n    // Reset prevProps when screen changes\n    prevProps.current = null;\n  }, [currentScreen]);\n\n  useEffect(() => {\n    if (prevProps.current) {\n      const changedProps: Record<string, { from: any; to: any }> = {};\n      for (const key of Object.keys(props)) {\n        if (prevProps.current[key] !== props[key]) {\n          changedProps[key] = {\n            from: prevProps.current[key],\n            to: props[key],\n          };\n        }\n      }\n      if (Object.keys(changedProps).length > 0) {\n        incrementReRender(componentName);\n        console.log(\n          `[useoptic] ${componentName} re-rendered. Changed props:`,\n          changedProps\n        );\n      }\n    }\n    prevProps.current = props;\n  });\n}\n\nlet renderTrackingSetup = false;\n\n/**\n * Sets up global render tracking (one-time log).\n */\nexport function setupRenderTracking() {\n  if (!renderTrackingSetup) {\n    renderTrackingSetup = true;\n    console.log('[useoptic] Re-render tracking enabled');\n  }\n}\n","export { InitOptic } from './core/initOptic';\nexport { Overlay } from './overlay/Overlay';\nexport { useRenderMonitor } from './metrics/reRenders';\nexport { useScreenMetrics } from './metrics/screen';\n","export type InitOpticOptions = {\n  tti?: boolean;\n  startup?: boolean;\n  reRenders?: boolean;\n};\n\n/**\n * Initializes Optic performance logging systems based on options.\n * All features are enabled by default.\n */\nexport async function InitOptic(options: InitOpticOptions = {}) {\n  const {\n    tti = true,\n    startup = true,\n    reRenders = true,\n  } = options;\n\n  if (tti) {\n    const { trackTTI } = await import('../metrics/tti');\n    trackTTI();\n    console.log('[Optic] TTI tracking enabled');\n  }\n  if (startup) {\n    const { trackStartupTime } = await import('../metrics/startup');\n    trackStartupTime();\n    console.log('[Optic] Startup tracking enabled');\n  }\n  if (reRenders) {\n    const { setupRenderTracking } = await import('../metrics/reRenders');\n    setupRenderTracking();\n    console.log('[Optic] Re-render tracking enabled');\n  }\n}\n","import React, { useRef, useState } from 'react';\nimport { View, Text, StyleSheet, PanResponder, Animated, Dimensions } from 'react-native';\nimport { useMetricsStore } from '../store/metricsStore';\nimport { SafeAreaView } from 'react-native-safe-area-context';\n\nconst { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');\n\nconst METRICS_THRESHOLDS = {\n  TTI: {\n    good: 20,\n    warning: 50,\n  },\n  STARTUP: {\n    good: 150,\n    warning: 200,\n  },\n};\n\nconst getMetricColor = (value: number | null, type: 'TTI' | 'STARTUP') => {\n  if (value === null) return '#fff';\n  const thresholds = METRICS_THRESHOLDS[type];\n  if (value <= thresholds.good) return '#4CAF50'; // Green\n  if (value <= thresholds.warning) return '#FFC107'; // Yellow\n  return '#F44336'; // Red\n};\n\nexport const Overlay: React.FC = () => {\n  const currentScreen = useMetricsStore((state) => state.currentScreen);\n  const screens = useMetricsStore((state) => state.screens);\n  const startupTime = useMetricsStore((state) => state.startupTime);\n\n  const pan = useRef(new Animated.ValueXY()).current;\n  const [position, setPosition] = useState({ x: SCREEN_WIDTH - 200, y: 100 });\n\n  const panResponder = useRef(\n    PanResponder.create({\n      onStartShouldSetPanResponder: () => true,\n      onPanResponderMove: (_, gesture) => {\n        const newX = position.x + gesture.dx;\n        const newY = position.y + gesture.dy;\n\n        // Keep within screen bounds\n        const boundedX = Math.max(0, Math.min(newX, SCREEN_WIDTH - 180));\n        const boundedY = Math.max(0, Math.min(newY, SCREEN_HEIGHT - 200));\n\n        pan.setValue({ x: boundedX - position.x, y: boundedY - position.y });\n      },\n      onPanResponderRelease: (_, gesture) => {\n        const newX = position.x + gesture.dx;\n        const newY = position.y + gesture.dy;\n\n        // Keep within screen bounds\n        const boundedX = Math.max(0, Math.min(newX, SCREEN_WIDTH - 180));\n        const boundedY = Math.max(0, Math.min(newY, SCREEN_HEIGHT - 200));\n\n        setPosition({ x: boundedX, y: boundedY });\n        pan.setValue({ x: 0, y: 0 });\n      },\n    })\n  ).current;\n\n  const currentScreenMetrics = currentScreen ? screens[currentScreen] : null;\n\n  return (\n    <SafeAreaView style={styles.safeArea} pointerEvents=\"box-none\">\n      <Animated.View\n        style={[\n          styles.overlay,\n          {\n            transform: [\n              { translateX: pan.x },\n              { translateY: pan.y },\n            ],\n            left: position.x,\n            top: position.y,\n          },\n        ]}\n        {...panResponder.panHandlers}\n      >\n        <View style={styles.dragHandle} />\n        <View style={styles.header}>\n          <Text style={styles.text}>App Performance</Text>\n          <Text style={styles.screenName}>\n            {currentScreen || 'No Screen'}\n          </Text>\n        </View>\n        \n        <View style={styles.metricsContainer}>\n          <View style={styles.metricRow}>\n            <Text style={styles.metricLabel}>TTI:</Text>\n            <Text \n              style={[\n                styles.metricValue,\n                { color: getMetricColor(currentScreenMetrics?.tti || null, 'TTI') }\n              ]}\n            >\n              {currentScreenMetrics?.tti !== null ? `${currentScreenMetrics?.tti}ms` : '...'}\n            </Text>\n          </View>\n\n          <View style={styles.metricRow}>\n            <Text style={styles.metricLabel}>Startup:</Text>\n            <Text \n              style={[\n                styles.metricValue,\n                { color: getMetricColor(startupTime, 'STARTUP') }\n              ]}\n            >\n              {startupTime !== null ? `${startupTime}ms` : '...'}\n            </Text>\n          </View>\n\n          {currentScreenMetrics && Object.keys(currentScreenMetrics.reRenderCounts).length > 0 && (\n            <View style={styles.reRendersContainer}>\n              <Text style={styles.metricLabel}>Re-renders:</Text>\n              {Object.entries(currentScreenMetrics.reRenderCounts).map(([name, count]) => (\n                <View key={name} style={styles.reRenderRow}>\n                  <Text style={styles.reRenderName}>{name}</Text>\n                  <Text style={styles.reRenderCount}>{count}</Text>\n                </View>\n              ))}\n            </View>\n          )}\n        </View>\n      </Animated.View>\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  safeArea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    pointerEvents: 'box-none',\n  },\n  overlay: {\n    position: 'absolute',\n    backgroundColor: 'rgba(33, 33, 33, 0.95)',\n    paddingVertical: 12,\n    paddingHorizontal: 16,\n    borderRadius: 12,\n    zIndex: 9999,\n    elevation: 20,\n    minWidth: 200,\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 4,\n    },\n    shadowOpacity: 0.3,\n    shadowRadius: 4.65,\n  },\n  dragHandle: {\n    width: 40,\n    height: 4,\n    backgroundColor: 'rgba(255, 255, 255, 0.2)',\n    borderRadius: 2,\n    alignSelf: 'center',\n    marginBottom: 12,\n  },\n  header: {\n    marginBottom: 12,\n  },\n  text: {\n    color: '#fff',\n    fontWeight: '600',\n    fontSize: 16,\n    letterSpacing: 0.5,\n  },\n  screenName: {\n    color: '#fff',\n    fontSize: 13,\n    opacity: 0.7,\n    marginTop: 2,\n  },\n  metricsContainer: {\n    gap: 8,\n  },\n  metricRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  metricLabel: {\n    color: '#fff',\n    fontSize: 13,\n    opacity: 0.7,\n  },\n  metricValue: {\n    fontSize: 13,\n    fontWeight: '500',\n  },\n  reRendersContainer: {\n    marginTop: 4,\n    borderTopWidth: 1,\n    borderTopColor: 'rgba(255, 255, 255, 0.1)',\n    paddingTop: 8,\n  },\n  reRenderRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginTop: 4,\n  },\n  reRenderName: {\n    color: '#fff',\n    fontSize: 12,\n    opacity: 0.7,\n  },\n  reRenderCount: {\n    color: '#fff',\n    fontSize: 12,\n    fontWeight: '500',\n  },\n});\n","import { useEffect, useRef, useCallback } from 'react';\nimport { useMetricsStore } from '../store/metricsStore';\n\ndeclare global {\n  var __OPTIC_SCREEN_TTI_CAPTURED__: Record<string, boolean>;\n  var __OPTIC_SCREEN_TTI_START__: Record<string, number>;\n}\n\nif (!global.__OPTIC_SCREEN_TTI_CAPTURED__) {\n  global.__OPTIC_SCREEN_TTI_CAPTURED__ = {};\n}\n\nif (!global.__OPTIC_SCREEN_TTI_START__) {\n  global.__OPTIC_SCREEN_TTI_START__ = {};\n}\n\n/**\n * Hook to track screen performance metrics.\n * @param screenName Name of the current screen\n */\nexport function useScreenMetrics(screenName: string) {\n  console.log(`[useoptic] useScreenMetrics called for \"${screenName}\"`);\n  \n  const setCurrentScreen = useMetricsStore((state) => state.setCurrentScreen);\n  const setTTI = useMetricsStore((state) => state.setTTI);\n  const screens = useMetricsStore((state) => state.screens);\n  const prevScreenRef = useRef<string | null>(null);\n  const mountedRef = useRef(true);\n\n  // Memoize the screen change handler\n  const handleScreenChange = useCallback(() => {\n    console.log(`[useoptic] handleScreenChange called for \"${screenName}\"`);\n    const isNewScreen = prevScreenRef.current !== screenName;\n    if (isNewScreen) {\n      console.log(`[useoptic] New screen detected: \"${screenName}\"`);\n      prevScreenRef.current = screenName;\n      // Reset TTI capture flag for the new screen\n      global.__OPTIC_SCREEN_TTI_CAPTURED__[screenName] = false;\n      setCurrentScreen(screenName);\n      console.log(`[useoptic] Starting TTI measurement for \"${screenName}\"`);\n    }\n  }, [screenName, setCurrentScreen]);\n\n  // Handle screen changes\n  useEffect(() => {\n    console.log(`[useoptic] Screen change effect triggered for \"${screenName}\"`);\n    handleScreenChange();\n  }, [handleScreenChange]);\n\n  // Handle TTI measurement\n  useEffect(() => {\n    console.log(`[useoptic] TTI measurement effect triggered for \"${screenName}\"`);\n    mountedRef.current = true;\n\n    if (!global.__OPTIC_SCREEN_TTI_CAPTURED__[screenName]) {\n      console.log(`[useoptic] Measuring TTI for \"${screenName}\"`);\n      global.__OPTIC_SCREEN_TTI_CAPTURED__[screenName] = true;\n      global.__OPTIC_SCREEN_TTI_START__[screenName] = Date.now();\n      setTTI(null);\n\n      // Use requestAnimationFrame to ensure we measure after the screen is rendered\n      requestAnimationFrame(() => {\n        if (mountedRef.current) {\n          const start = global.__OPTIC_SCREEN_TTI_START__[screenName];\n          const tti = Date.now() - start;\n          console.log(`[useoptic] Setting TTI for \"${screenName}\": ${tti}ms`);\n          setTTI(tti);\n        }\n      });\n    } else {\n      console.log(`[useoptic] TTI already captured for \"${screenName}\"`);\n    }\n\n    return () => {\n      console.log(`[useoptic] Cleaning up TTI measurement for \"${screenName}\"`);\n      mountedRef.current = false;\n      \n      // Only reset TTI if we're actually unmounting the screen\n      if (prevScreenRef.current !== screenName) {\n        if (screens[screenName]) {\n          setTTI(null);\n        }\n      }\n    };\n  }, [screenName, setTTI, screens]);\n} "],"mappings":"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","names":["state","trackTTI","trackStartupTime","setupRenderTracking","React","import_react"]}